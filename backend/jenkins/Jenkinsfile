// AutoDeployX Jenkins Pipeline
// CI/CD: Build â†’ Test â†’ Security Scan â†’ Push â†’ Deploy to Minikube
// DockerHub: sarika1731/autodeployx
// Features: Parallel stages, Code quality, Security scanning, Notifications, Rollback

pipeline {
    agent any

    environment {
        DOCKER_IMAGE = "sarika1731/autodeployx"
        DEPLOY_NAMESPACE = "default"
        SLACK_CHANNEL = "#deployments"  // Configure in Jenkins
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
    }

    parameters {
        string(name: 'PIPELINE_ID', defaultValue: '', description: 'Backend pipeline ID for tracking')
        string(name: 'BACKEND_URL', defaultValue: 'http://localhost:8001', description: 'Backend API URL')
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Target environment')
        booleanParam(name: 'SKIP_TESTS', defaultValue: false, description: 'Skip test stage')
        booleanParam(name: 'SKIP_SECURITY_SCAN', defaultValue: false, description: 'Skip security scanning')
        string(name: 'DEPLOY_TAG', defaultValue: '', description: 'Specific tag to deploy (leave empty for BUILD_NUMBER)')
    }

    stages {
        stage('Pipeline Started') {
            steps {
                script {
                    // Set build description
                    currentBuild.description = "Env: ${params.ENVIRONMENT} | Branch: ${env.GIT_BRANCH ?: 'main'}"
                    
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/status \
                            -H "Content-Type: application/json" \
                            -d '{"status": "running", "pipeline_name": "AutoDeployX", "build_number": ${BUILD_NUMBER}, "stage": "started", "message": "Pipeline #${BUILD_NUMBER} started for ${params.ENVIRONMENT}", "branch": "${env.GIT_BRANCH ?: 'main'}", "pipeline_id": "${params.PIPELINE_ID}"}' || true
                    """
                }
            }
        }

        stage('Checkout') {
            steps {
                script {
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Checkout", "status": "running"}' || true
                    """
                }
                checkout scm
                script {
                    // Get git info
                    env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    env.GIT_AUTHOR = sh(script: 'git log -1 --pretty=format:"%an"', returnStdout: true).trim()
                    env.GIT_MESSAGE = sh(script: 'git log -1 --pretty=format:"%s"', returnStdout: true).trim()
                    
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Checkout", "status": "success"}' || true
                        
                        curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "checkout", "status": "success", "details": {"branch": "${env.GIT_BRANCH ?: 'main'}", "commit": "${env.GIT_COMMIT_SHORT}", "author": "${env.GIT_AUTHOR}"}}' || true
                    """
                }
            }
        }

        // ========== PARALLEL: Tests + Code Quality ==========
        stage('Quality Gates') {
            when {
                expression { !params.SKIP_TESTS }
            }
            parallel {
                stage('Unit Tests') {
                    steps {
                        script {
                            sh """
                                curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                                    -H "Content-Type: application/json" \
                                    -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Test", "status": "running"}' || true
                            """
                        }
                        dir('autodeploy/app') {
                            sh 'pip install -r requirements.txt pytest-cov || pip3 install -r requirements.txt pytest-cov'
                            sh 'python -m pytest ../tests/ -v --cov=. --cov-report=xml --cov-report=html || python3 -m pytest ../tests/ -v --cov=. --cov-report=xml --cov-report=html'
                        }
                        script {
                            sh """
                                curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                                    -H "Content-Type: application/json" \
                                    -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Test", "status": "success"}' || true
                                
                                curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                                    -H "Content-Type: application/json" \
                                    -d '{"event_type": "test", "status": "success", "details": {"tests_passed": true, "coverage": "enabled"}}' || true
                            """
                        }
                    }
                    post {
                        always {
                            // Archive test results
                            junit allowEmptyResults: true, testResults: '**/test-results/*.xml'
                            publishHTML(target: [
                                allowMissing: true,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: 'autodeploy/app/htmlcov',
                                reportFiles: 'index.html',
                                reportName: 'Coverage Report'
                            ])
                        }
                    }
                }

                stage('Lint & Static Analysis') {
                    steps {
                        dir('autodeploy/app') {
                            sh '''
                                pip install flake8 pylint || pip3 install flake8 pylint
                                flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true
                                pylint *.py --exit-zero --output-format=parseable > pylint-report.txt || true
                            '''
                        }
                    }
                    post {
                        always {
                            recordIssues(enabledForFailure: true, tool: pyLint(pattern: '**/pylint-report.txt'))
                        }
                    }
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Build", "status": "running"}' || true
                    """
                    
                    // Determine image tag
                    env.IMAGE_TAG = params.DEPLOY_TAG ?: "${BUILD_NUMBER}"
                }
                dir('autodeploy/docker') {
                    sh """
                        docker build \
                            --build-arg BUILD_NUMBER=${BUILD_NUMBER} \
                            --build-arg GIT_COMMIT=${env.GIT_COMMIT_SHORT} \
                            --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                            --label "build.number=${BUILD_NUMBER}" \
                            --label "git.commit=${env.GIT_COMMIT_SHORT}" \
                            -t ${DOCKER_IMAGE}:${env.IMAGE_TAG} \
                            -t ${DOCKER_IMAGE}:latest \
                            -f Dockerfile ..
                    """
                }
                script {
                    // Get image size
                    env.IMAGE_SIZE = sh(script: "docker images ${DOCKER_IMAGE}:${env.IMAGE_TAG} --format '{{.Size}}'", returnStdout: true).trim()
                    
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Build", "status": "success"}' || true
                        
                        curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "build", "status": "success", "details": {"image": "${DOCKER_IMAGE}:${env.IMAGE_TAG}", "size": "${env.IMAGE_SIZE}"}}' || true
                    """
                }
            }
        }

        // ========== Security Scanning ==========
        stage('Security Scan') {
            when {
                expression { !params.SKIP_SECURITY_SCAN }
            }
            parallel {
                stage('Trivy Vulnerability Scan') {
                    steps {
                        script {
                            sh """
                                curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                                    -H "Content-Type: application/json" \
                                    -d '{"event_type": "security_scan", "status": "running", "details": {"scanner": "trivy"}}' || true
                            """
                        }
                        sh """
                            # Install Trivy if not present
                            which trivy || (curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin)
                            
                            # Scan for vulnerabilities (fail on HIGH/CRITICAL)
                            trivy image --exit-code 0 --severity HIGH,CRITICAL --format table ${DOCKER_IMAGE}:${env.IMAGE_TAG} || true
                            
                            # Generate JSON report for dashboard
                            trivy image --format json --output trivy-report.json ${DOCKER_IMAGE}:${env.IMAGE_TAG} || true
                        """
                        script {
                            sh """
                                curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                                    -H "Content-Type: application/json" \
                                    -d '{"event_type": "security_scan", "status": "success", "details": {"scanner": "trivy", "report": "generated"}}' || true
                            """
                        }
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'trivy-report.json', allowEmptyArchive: true
                        }
                    }
                }

                stage('Docker Lint') {
                    steps {
                        sh '''
                            # Lint Dockerfile with hadolint
                            docker run --rm -i hadolint/hadolint < autodeploy/docker/Dockerfile || true
                        '''
                    }
                }
            }
        }

        stage('Push to DockerHub') {
            steps {
                script {
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Push", "status": "running"}' || true
                    """
                }
                withCredentials([usernamePassword(credentialsId: 'dockerhub', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                    sh 'echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin'
                    sh "docker push ${DOCKER_IMAGE}:${env.IMAGE_TAG}"
                    sh "docker push ${DOCKER_IMAGE}:latest"
                    
                    // Tag with environment
                    sh "docker tag ${DOCKER_IMAGE}:${env.IMAGE_TAG} ${DOCKER_IMAGE}:${params.ENVIRONMENT}-latest"
                    sh "docker push ${DOCKER_IMAGE}:${params.ENVIRONMENT}-latest"
                    
                    sh 'docker logout'
                }
                script {
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Push", "status": "success"}' || true
                        
                        curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "push", "status": "success", "details": {"registry": "DockerHub", "image": "${DOCKER_IMAGE}:${env.IMAGE_TAG}", "environment": "${params.ENVIRONMENT}"}}' || true
                    """
                }
            }
        }

        // ========== Deployment with Rollback Support ==========
        stage('Deploy to Minikube') {
            steps {
                script {
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Deploy", "status": "running"}' || true
                    """
                    
                    // Save current deployment for rollback
                    env.PREVIOUS_IMAGE = sh(
                        script: "kubectl get deployment autodeployx-app -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo 'none'",
                        returnStdout: true
                    ).trim()
                    echo "Previous image: ${env.PREVIOUS_IMAGE}"
                }
                
                // Deploy with rolling update strategy
                sh """
                    # Apply namespace and configs first
                    kubectl apply -f autodeploy/k8s/service.yaml
                    
                    # Update deployment with new image
                    kubectl set image deployment/autodeployx-app \
                        autodeployx-app=${DOCKER_IMAGE}:${env.IMAGE_TAG} \
                        --record || kubectl apply -f autodeploy/k8s/deployment.yaml
                    
                    # Wait for rollout
                    kubectl rollout status deployment/autodeployx-app --timeout=180s
                """
                
                // Verify deployment
                sh '''
                    echo "=== Deployment Status ==="
                    kubectl get deployment autodeployx-app -o wide
                    
                    echo "=== Running Pods ==="
                    kubectl get pods -l app=autodeployx-app
                    
                    echo "=== Pod Events ==="
                    kubectl describe pods -l app=autodeployx-app | tail -20
                '''
                
                script {
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "Deploy", "status": "success"}' || true
                        
                        curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "deploy", "status": "success", "details": {"cluster": "minikube", "namespace": "${DEPLOY_NAMESPACE}", "version": "${env.IMAGE_TAG}", "environment": "${params.ENVIRONMENT}"}}' || true
                    """
                }
            }
            post {
                failure {
                    script {
                        echo "Deployment failed! Initiating rollback..."
                        if (env.PREVIOUS_IMAGE != 'none') {
                            sh """
                                kubectl rollout undo deployment/autodeployx-app
                                kubectl rollout status deployment/autodeployx-app --timeout=120s
                                
                                curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                                    -H "Content-Type: application/json" \
                                    -d '{"event_type": "rollback", "status": "success", "details": {"reason": "deployment_failed", "rolled_back_to": "${env.PREVIOUS_IMAGE}"}}' || true
                            """
                        }
                    }
                }
            }
        }

        // ========== Health Verification ==========
        stage('Health Check') {
            steps {
                script {
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "HealthCheck", "status": "running"}' || true
                    """
                }
                
                retry(3) {
                    sleep(time: 10, unit: 'SECONDS')
                    sh '''
                        # Get service URL from Minikube
                        SERVICE_URL=$(minikube service autodeployx-service --url 2>/dev/null || echo "http://localhost:5000")
                        
                        echo "Testing health endpoint: ${SERVICE_URL}/health"
                        
                        # Health check with retry
                        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" ${SERVICE_URL}/health || echo "000")
                        
                        if [ "$HTTP_STATUS" = "200" ]; then
                            echo "âœ… Health check passed!"
                        else
                            echo "âŒ Health check failed with status: $HTTP_STATUS"
                            exit 1
                        fi
                    '''
                }
                
                script {
                    sh """
                        curl -X POST ${params.BACKEND_URL}/api/jenkins/stage \
                            -H "Content-Type: application/json" \
                            -d '{"pipeline_id": "${params.PIPELINE_ID}", "stage_name": "HealthCheck", "status": "success"}' || true
                        
                        curl -X POST ${params.BACKEND_URL}/api/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "health_check", "status": "success", "details": {"endpoint": "/health"}}' || true
                    """
                }
            }
        }

        // ========== Smoke Tests ==========
        stage('Smoke Tests') {
            steps {
                sh '''
                    SERVICE_URL=$(minikube service autodeployx-service --url 2>/dev/null || echo "http://localhost:5000")
                    
                    echo "=== Running Smoke Tests ==="
                    
                    # Test API endpoints
                    echo "Testing /health..."
                    curl -sf ${SERVICE_URL}/health && echo " âœ… PASS" || echo " âŒ FAIL"
                    
                    echo "Testing /api/status..."
                    curl -sf ${SERVICE_URL}/api/status && echo " âœ… PASS" || echo " âš ï¸ SKIP (optional)"
                    
                    echo "=== Smoke Tests Complete ==="
                '''
            }
        }
    }

    post {
        success {
            script {
                sh """
                    curl -X POST ${params.BACKEND_URL}/api/jenkins/status \
                        -H "Content-Type: application/json" \
                        -d '{"status": "success", "pipeline_name": "AutoDeployX", "build_number": ${BUILD_NUMBER}, "stage": "complete", "message": "Pipeline #${BUILD_NUMBER} deployed to ${params.ENVIRONMENT} successfully", "branch": "${env.GIT_BRANCH ?: 'main'}"}' || true
                """
            }
            echo """
            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            â•‘  ğŸ‰ DEPLOYMENT SUCCESSFUL                            â•‘
            â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
            â•‘  Build:       #${BUILD_NUMBER}                       
            â•‘  Environment: ${params.ENVIRONMENT}                  
            â•‘  Image:       ${DOCKER_IMAGE}:${env.IMAGE_TAG}       
            â•‘  Commit:      ${env.GIT_COMMIT_SHORT}                
            â•‘  Author:      ${env.GIT_AUTHOR}                      
            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """
            
            // Slack notification (if configured)
            // slackSend channel: env.SLACK_CHANNEL, color: 'good', message: "âœ… AutoDeployX #${BUILD_NUMBER} deployed to ${params.ENVIRONMENT}"
        }
        
        failure {
            script {
                sh """
                    curl -X POST ${params.BACKEND_URL}/api/jenkins/status \
                        -H "Content-Type: application/json" \
                        -d '{"status": "failure", "pipeline_name": "AutoDeployX", "build_number": ${BUILD_NUMBER}, "stage": "failed", "message": "Pipeline #${BUILD_NUMBER} failed"}' || true
                """
            }
            echo 'âŒ Pipeline failed! Check logs for details.'
            
            // Slack notification (if configured)
            // slackSend channel: env.SLACK_CHANNEL, color: 'danger', message: "âŒ AutoDeployX #${BUILD_NUMBER} FAILED"
        }
        
        unstable {
            echo 'âš ï¸ Pipeline completed with warnings'
        }
        
        always {
            // Cleanup
            sh 'docker logout || true'
            sh "docker rmi ${DOCKER_IMAGE}:${env.IMAGE_TAG} || true"
            cleanWs()
            
            // Archive build artifacts
            archiveArtifacts artifacts: '**/test-results/**/*.xml, **/coverage/**/*', allowEmptyArchive: true
        }
    }
}
